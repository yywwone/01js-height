<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script>
    // 把放在外面的所有的共同的方法 都放入一个json对象中
    //防止命名冲突 设置一个命名空间
    //  var json = {

    //   pringScore:function () {
    //     console.log(this.name+ "的分数为"+this.score);
    //   }, 
    //   study:function() {
    //     console.log(this.name +"正在学习")
    //   }


    //  }




    function CreateStudent(name, score) {
      //内存中有一个地址上面有这个对象 
      this.name = name;
      this.score = score;
     
      // return [];
    }
    // CreateStudent.prototype = {
    //   constructor : CreateStudent,// 我必须手动把之前的构造函数的指向改回来
    //   printScore: function () {
    //     console.log(this.name + "的分数为" + this.score);
    //   },
    //   study: function () {
    //     console.log(this.name + "正在学习")
    //   }
    // }

    // 直接给构造函数的原型上面添加方法 以后一般这样写
    CreateStudent.prototype.printScore = function () {
      console.log(this.name + "的分数为" + this.score);
    }

    CreateStudent.prototype.study = function () {
        console.log(this.name + "正在学习")
      }


    var s1 = new CreateStudent("Michael", 98);// 构造函数有一个不成文规定 名称首字母大写
    var s2 = new CreateStudent("Bob", 81);

    s1.printScore();
    s2.printScore();

    console.log(s1.printScore==s2.printScore)
    // 实例对象.constructor: 获取一个实例的构造函数
    
   
    // 构造函数身上有一个属性  prototype 原型 它本身就是一个对象
    // CreateStudent.prototype = { constructor : CreateStudent}
   





    var obj = {
      name :"zs"
    }

    obj.age = 33;
    obj.job = "aa";
    // var obj = {
    //   job:"aa",
    //   age : 33
    // }
    console.log(obj)

   /* var arr = new Array();

    push  pop  shift unshift  join  slice  concat  splice  
    reverse sort  */
  </script>
</head>

<body>

</body>

</html>